<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      for (let i = 0; i < 6; i++) {
        document.write("<div>");
        for (let j = 0; j < 6; j++) {
          document.write("♥");
        }
        document.write("</div>");
      }
      document.write("=========================");
      for (let i = 0; i < 6; i++) {
        document.write("<div>");
        for (let j = 0; j < i + 1; j++) {
          document.write("♥");
        }
        document.write("</div>");
      }

      // 1.生成指定数字的数组
      const getArr = (b, e) => {
        let arr = [];
        for (let i = b; i <= e; i++) {
          arr.push(i);
        }
        return arr;
      };
      console.log(getArr(2, 8));
      // 2.获取数组最大值
      const getMax = (arr) => {
        return Math.max(...arr);
      };
      console.log(getMax([2, 3, 7, 8, 1]));
      // 3.数组去重
      const qcArr = (arr) => {
        // return Array.from(new Set(arr));
        // const res = arr.filter((item, index, self) => {
        //   console.log(item, index, self);
        //   return self.indexOf(item) === index;
        // });
        // return res;
        // let res = [];
        // for (let i = 0; i < arr.length; i++) {
        //   if (res.indexOf(arr[i]) === -1) {
        //     res.push(arr[i]);
        //   }
        // }
        // return res;
        return [...new Set(arr)];
      };
      console.log(qcArr([1, 2, 3, 3, 3, 11, 3, 3, 4, 55, 6, 1, 666]));

      // 5.获取斐波那契数列
      const getFibArr = (n) => {
        let fibArr1 = [];
        for (let i = 0; i < n; i++) {
          if (i <= 1) {
            fibArr1.push(i);
          } else {
            fibArr1.push(fibArr1[i - 1] + fibArr1[i - 2]);
          }
        }

        let fibArr2 = [];
        let i = 0;
        while (i < n) {
          if (i <= 1) {
            fibArr2.push(i);
          } else {
            fibArr2.push(fibArr2[i - 1] + fibArr2[i - 2]);
          }
          i++;
        }

        return { fibArr1, fibArr2 };
      };
      console.log(getFibArr(20));

      // 斐波那契数列第n项 0 1 1 2 3 5 8 13
      const fibonacci = (n) => {
        if (n === 1) return 0;
        if (n === 2) return 1;
        // let f1 = 0;
        // let f2 = 1;
        // let fn = n;
        // for (let i = 2; i < n; i++) {
        //   fn = f1 + f2;
        //   f1 = f2;
        //   f2 = fn;
        // }
        // return fn;
        return fibonacci(n - 1) + fibonacci(n - 2);
      };
      console.log(fibonacci(20));

      // 递归加缓存
      let memoArr = [];
      const getMemoFib = (n) => {
        if (n === 1) return 0;
        if (n === 2) return 1;
        if (!memoArr[n - 1]) {
          memoArr[n - 1] = getMemoFib(n - 1);
        }
        if (!memoArr[n - 2]) {
          memoArr[n - 2] = getMemoFib(n - 2);
        }
        return memoArr[n - 1] + memoArr[n - 2];
      };

      console.log(getMemoFib(50));

      // 动态规划
      const fibSuper = (n) => {
        if (n === 1) return 0;
        if (n === 2) return 1;
        const arr = [0, 1];
        for (let i = 2; i < n; i++) {
          arr.push(arr[0] + arr[1]);
          arr.splice(0, 1);
        }
        return arr[1];
      };
      console.log(fibSuper(50));

      //求数列
      const fib = (n) => {
        const arr = [0, 1];
        if (n === 1) return [0];
        if (n === 2) return [0, 1];
        for (let i = 2; i < n; i++) {
          arr[i] = arr[i - 1] + arr[i - 2];
        }
        return arr;
      };
      console.log(fib(50));
    </script>
  </body>
</html>
